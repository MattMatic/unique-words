<html>

<head>
<meta charset="utf-8">
<!--
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gulzar|Noto+Nastaliq+Urdu">
-->
<style>
  body {
    font-family: "Calibri";
    background-color: #aacccc;
  }
.test_font {
  font-family: "Test_Font";
  font-kerning: normal;
  font-size: 200%;
  color: #000080;
  text-align: center;
}
input[type="text"] {
  font-size: 100%;
}
table, th, td {
  border: 2px solid #448888;
  border-collapse: collapse;
  padding: 8px;
}
textarea {
  font-family: "Noto Sans";
  font-size: 100%;
}
</style>
</head>
<body>

<script>

// polyfill for scheduler.yield
globalThis.scheduler = globalThis.scheduler || {};
globalThis.scheduler.yield = 
  globalThis.scheduler.yield || 
  (() => new Promise((r) => setTimeout(r, 0)));

class ElapsedTimer {
  constructor(t=32) {
    this.max = t;
    this.next = performance.now() + t;
  }
  elapsed() {
    const now = performance.now();
    if (now < this.next) return false;
    while (now > this.next) this.next += this.max;
    return true;
  }
}

async function findUniqueWords(input, options) {
  let lang = options.language;
  if (lang === '') lang = undefined;
  let segmenter = new Intl.Segmenter(lang, {granularity: 'word'});
  let segments = segmenter.segment(input);
  let words = {};
  var wordCount = 0;
  var numberCount = 0;
  let counter = 0;
  let et = new ElapsedTimer();

  for (let {segment, index, isWordLike} of segments) {
    counter++;
    if (et.elapsed()) {
      inputCount.innerText = 'Progress: '+wordCount+' / '+counter;
      await scheduler.yield();
    }
    if (isWordLike) {
      wordCount++;
      let hasNumbers =  /\d/.test(segment);
      if (hasNumbers) numberCount++;
      if (!hasNumbers || options.numbers) {
        if (options.normalize) segment = segment.normalize();
        words[segment] = true;  // Assimilate a list
      }
    }
  }
  var res = [];
  for (const word in words) {
    if (typeof options.ignore === 'string') {
      let found = false;
      for (let c of word) {
        if (options.ignore.indexOf(c) >= 0) {
          found = true;
          break;
        }
      }
      if (found) {
        continue;
      };
    }
    res.push(word);
  }
  if (options.sort) {
    res.sort();
  }
  return {
    unique: res,
    inputCount: wordCount,
    numberCount: numberCount,
  };
}

let blobText = '';
let outputWords = '';

async function pasteInputText() {
  // Access clipboard and use Intl.segmenter to pull out words
  let input = '';
  inputCount.innerText = '...pasting...';
  //try {
    const clipboardContents = await navigator.clipboard.read();
    for (const item of clipboardContents) {
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        blobText = await blob.text();
        if (blobText.length < 1024*1024)
          inputText.value = blobText;
        else
          inputText.value = '(too large to show)';
        processInputText();
      }
    }
  //} catch (error) {
  //  console.log(error.message);
  //}
}

function updateInputText() {
  blobText = inputText.value;
  processInputText();
}

async function processInputText() {
  const input = blobText;
  var options = {
    language: HTMLLang.value,
    numbers: cbNumbers.checked,
    sort: cbSort.checked,
    normalize: cbNormalize.checked,
  };
  const ignore = inputIgnore.value;
  if (ignore !== '') {
    try {
      const ignoreDecoded = decodeURIComponent(JSON.parse('"'+ignore+'"'));
      options.ignore = ignoreDecoded;      
    } catch (e) {
      //console.log(e.message);
    }
  }
  var wordsResult = await findUniqueWords(input, options);
  const words = wordsResult.unique;
  var txt = wordsResult.inputCount + ' words';
  if (wordsResult.numberCount > 0) txt += ', '+wordsResult.numberCount+' numbers';
  inputCount.innerText = txt;
  uniqueCount.innerText = words.length + ' words';
  uniqueWordList = words;
  outputWords = words.join('\r\n');
  if (outputWords.length > 2*1024*1024) {
    outputText.value = '(too large)';
  } else {
    outputText.value = outputWords;
  }
}

function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function downloadUniqueWords() {
  var bb = new Blob([outputWords], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = 'UniqueWords.'+DateTimeForFilename()+'.txt';
  a.href = window.URL.createObjectURL(bb);
  a.target = '_blank';
  a.click();
}

// Update the document language tag
function updateLanguage() {
  document.documentElement.setAttribute('lang', HTMLLang.value);
}

</script>


<h1>Unique Words</h1>

<table border=0 width='100%'>
<tr><th width='20%'>HTML Language</th><td><input type='text' id='HTMLLang' oninput='updateLanguage();' title='Web page language ID'/></td></tr>

<tr><th>Options</th>
  <td>
    <input type='checkbox' id='cbNumbers' onclick='processInputText();'>Numbers</input>
    <input type='checkbox' id='cbNormalize' onclick='processInputText();'>Normalize</input>
    <input type='checkbox' id='cbSort' onclick='processInputText();' checked>Sort</input>
    </br>
    Ignore Characters:<input type='text' id='inputIgnore' size=64 oninput='processInputText();'></input></br>(use e.g. `\u06f0` for Unicode)
  </td>
</tr>

<tr><th>Input</br><button onclick='pasteInputText();'>Paste</button></th>
  <td><textarea style="width:100%" id="inputText" rows='8' oninput="updateInputText();">(paste text here)</textarea><div id='inputCount'>-</div>
</td></tr>

<tr><th>Unique</br><button onclick='downloadUniqueWords();'>Download</button></th>
<td><textarea style="width:100%" id="outputText" rows='20'></textarea><div id='uniqueCount'>-</div></td>
</tr></table>

<a href='https://github.com/MattMatic/unique-words'>github.com/MattMatic/unique-words</a>
</br>2025-07-28
</body>
</html>

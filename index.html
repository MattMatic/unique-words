<html>

<head>
<meta charset="utf-8">
<!--
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Gulzar|Noto+Nastaliq+Urdu">
-->
<style>
  body {
    font-family: "Calibri";
    background-color: #aacccc;
  }
.test_font {
  font-family: "Test_Font";
  font-kerning: normal;
  font-size: 200%;
  color: #000080;
  text-align: center;
}
input[type="text"] {
  font-size: 100%;
}
table, th, td {
  border: 2px solid #448888;
  border-collapse: collapse;
  padding: 8px;
}
textarea {
  font-family: "Noto Sans";
  font-size: 100%;
}
dialog::backdrop {
  background-color: hsl(100, 40%, 50%, 0.3);
}
dialog {
  background-color: #e8ece8;
}
[aria-label="close"] {
  appearance: none;
  background-color: #fcc;
  float: right;
  border: 1px solid;
  border-radius: 50%;
}

</style>
</head>
<body>

<script>

const MAXIMUM_TEXT_SIZE = 100000;
const TOO_LARGE_TO_SHOW = 'TEXT TOO LARGE\r\n(Showing first '+MAXIMUM_TEXT_SIZE+' chars)\r\n\r\n';

// polyfill for scheduler.yield
globalThis.scheduler = globalThis.scheduler || {};
globalThis.scheduler.yield = 
  globalThis.scheduler.yield || 
  (() => new Promise((r) => setTimeout(r, 0)));

class ElapsedTimer {
  constructor(t=32) {
    this.max = t;
    this.next = performance.now() + t;
  }
  elapsed() {
    const now = performance.now();
    if (now < this.next) return false;
    while (now > this.next) this.next += this.max;
    return true;
  }
}

function disableControls(doDisable = true) {
  cbNumbers.disabled = doDisable;
  cbSort.disabled = doDisable;
  cbNormalize.disabled = doDisable;
  btnPaste.disabled = doDisable;
  inputText.disabled = doDisable;
  inputIgnore.disabled = doDisable;
  if (doDisable) {
    btnUpdate.disabled = doDisable;
  }
  btnDownload.disabled = doDisable;
  btnCopyToClipboard.disabled = doDisable;
  HTMLLang.disabled = doDisable;
}

let abortTheLoop = false;
let ignoreWords = new Set();

function doAbortTheLoop() {
  abortTheLoop = true;
}

async function findUniqueWords(input, options, ignoreWords) {
  let lang = options.language;
  if (lang === '') lang = undefined;
  let segmenter = new Intl.Segmenter(lang, {granularity: 'word'});
  let words = new Set();
  var wordCount = 0;
  var numberCount = 0;
  let counter = 0;
  let et = new ElapsedTimer();
  abortTheLoop = false;

  btnAbort.hidden = false;

  let punc = '';
  let word = '';
  let puncpre = '';

  const addWord = function() {
    if (word.length > 0) {
      words.add(puncpre + word + punc);
      if (options.justword) words.add(word);
    }
    word = '';
    puncpre = '';
  };

  let segments = segmenter.segment(input);
  for (let {segment, index, isWordLike} of segments) {
    counter++;
    if (et.elapsed()) {
      inputCount.innerText = 
        'Progress: '+wordCount+' / '+counter;
      await scheduler.yield();
    }
    if (abortTheLoop) break;
    if (isWordLike) {
      wordCount++;
      let hasNumbers =  /\p{Number}/u.test(segment); // Unicode aware numbers
      if (hasNumbers) numberCount++;
      if (!hasNumbers || options.numbers) {
        //word = punc + segment;
        word = segment;
        puncpre = punc;
        punc = '';
        if (options.normalize)
          word = word.normalize();
      }
    } else {
      if (options.punctuation) {
        let r = segment.match(/^(\p{P}*)$/gu);
        if (r && r[0]) {
          punc += r[0];
        } else {
          addWord();
          punc = '';
        }
      } else {
        addWord();
      }
    }
  }
  addWord();

  btnAbort.hidden = true;

  if (ignoreWords) {
    inputCount.innerText = '...ignore words...';
    words = words.difference(ignoreWords);
  }

  inputCount.innerText = '...filtering...';
  await scheduler.yield();

  var res = [];
  words.forEach((word) => {
    let found = false;
    if (typeof options.ignore === 'string') {
      for (let c of word) {
        if (options.ignore.indexOf(c) >= 0) {
          found = true;
          break;
        }
      }
    }
    if (!found) res.push(word);
  });

  inputCount.innerText = '...sorting..';
  await scheduler.yield();

  if (options.sort) {
    res.sort();
  }

  return {
    unique: res,
    inputCount: wordCount,
    numberCount: numberCount,
  };
}

//------------------------------
// Drag and drop utilities
//------------------------------
function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);
window.addEventListener('beforeunload', function(e) {
  if (!checkListChanged) return undefined;
  var confirmMessage = 'CheckList is not yet saved. If you leave before saving, changes will be lost!';
  (e || window.event).returnValue = confirmMessage;
  return confirmMessage;
});

let blobText = '';
let outputWords = '';

async function pasteInputText() {
  // Access clipboard and use Intl.segmenter to pull out words
  let input = '';
  inputCount.innerText = '...pasting...';
  //try {
    const clipboardContents = await navigator.clipboard.read();
    for (const item of clipboardContents) {
      if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        blobText = await blob.text();
        processInputText();
      }
    }
  //} catch (error) {
  //  console.log(error.message);
  //}
}

async function pasteIgnoreWords() {
  let input = '';
  ignoreWords.clear();
  const clipboardContents = await navigator.clipboard.read();
  for (const item of clipboardContents) {
    if (item.types.includes('text/plain')) {
      const blob = await item.getType('text/plain');
      let txt = await blob.text();
      processIgnoreWords(txt);
    }
  }
  processInputText();
}

async function clearIgnoreWords() {
  ignoreWords.clear();
  processIgnoreWords('');
  processInputText();
}

function updateInputText() {
  blobText = inputText.value;
  processInputText();
}

function optionsChanged() {
  let activeElement = document.activeElement;
  cbJustWord.disabled = !cbPunctuation.checked;
  if (blobText.length > MAXIMUM_TEXT_SIZE)
    btnUpdate.disabled = false;
  else
    processInputText();
  if (activeElement) {
    setTimeout( () => { activeElement.focus();} );
  }
}

function doUpdateButton() {
  processInputText();
}

async function processInputText() {
  let input = blobText;
  var options = {
    language: HTMLLang.value,
    numbers: cbNumbers.checked,
    sort: cbSort.checked,
    normalize: cbNormalize.checked,
    punctuation: cbPunctuation.checked,
    justword: cbJustWord.checked,
  };
  const ignore = inputIgnore.value;
  if (ignore !== '') {
    try {
      const ignoreDecoded = decodeURIComponent(JSON.parse('"'+ignore+'"'));
      options.ignore = ignoreDecoded;      
    } catch (e) {
      //console.log(e.message);
    }
  }
  disableControls(true);

  const reTxt = inputFilter.value;
  if (cbFilter.checked && (reTxt.length > 0)) {
    let inputNew = '';
    const re = new RegExp(reTxt, 'gu');
    const lines = input.split(/\r?\n+/g);
    lines.forEach( (line) => {
      re.lastIndex = 0;
      let res = re.exec(line);
      if (res) {
        inputNew += res.slice(1).join(' ')+'\r\n';
      }
    });
    input = inputNew;
  }

  if (input.length < MAXIMUM_TEXT_SIZE)
    inputText.value = input;
  else {
    inputText.value = TOO_LARGE_TO_SHOW + input.substr(0, MAXIMUM_TEXT_SIZE)+'...';
  }

  var wordsResult = await findUniqueWords(input, options, ignoreWords);
  const words = wordsResult.unique;
  var txt = wordsResult.inputCount + ' words';
  if (wordsResult.numberCount > 0) txt += ', '+wordsResult.numberCount+' numbers';
  inputCount.innerText = txt;
  uniqueCount.innerText = words.length + ' words';
  uniqueWordList = words;
  outputWords = words.join('\r\n');

  if (outputWords.length > MAXIMUM_TEXT_SIZE) {
    outputText.value = TOO_LARGE_TO_SHOW + outputWords.substr(0, MAXIMUM_TEXT_SIZE)+'...';
  } else {
    outputText.value = outputWords;
  }
  disableControls(false);
}

function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function downloadUniqueWords() {
  var bb = new Blob([outputWords], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = 'UniqueWords.'+DateTimeForFilename()+'.txt';
  a.href = window.URL.createObjectURL(bb);
  a.target = '_blank';
  a.click();
}

function copyUniqueWords() {
  navigator.clipboard.writeText(outputWords);
}

// Update the document language tag
function updateLanguage() {
  document.documentElement.setAttribute('lang', HTMLLang.value);
}

function handeInputDragDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    blobText = e.target.result;
    processInputText();
  }
  reader.readAsText(file);
}

function splitLinesToArray(txt) {
  var lines = txt.split(/\r?\n+/g);
  var tempWordList = [];  // Start empty
  lines.forEach( (line) => {
    tempWordList.push(line);
  });
  return tempWordList;
}

function processIgnoreWords(txt) {
  //ignoreWords.clear(); -- do this in the caller to allow multiple pastes
  let lines = splitLinesToArray(txt);
  let lang = HTMLLang.value;
  if (lang === '') lang = undefined;
  let segmenter = new Intl.Segmenter(lang, {granularity: 'word'});
  lines.forEach((line)=>{
    if (line.search(/^\s+[#;]/) < 0) {
      if (line.length > 0) {
        let segments = segmenter.segment(line);
        for (let {segment, index, isWordLike} of segments) {
          if (isWordLike) {
            ignoreWords.add(segment);
          }
          break; // Only consider the first segment
        }
      }
    }
  });

  tdIgnoreWords.innerText = `Words: ${ignoreWords.size}`;
}

function handleIgnoreDragDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;
  var reader = new FileReader();
  reader.onload = function(e) {
    let txt = e.target.result;
    ignoreWords.clear();
    processIgnoreWords(txt);
    processInputText();
  }
  reader.readAsText(file);
}

</script>


<h1>Unique Words</h1>

<table border=0 width='100%'>
<tr>
  <th width='20%'>
    HTML Language
  </th>
  <td>
    <input type='text' id='HTMLLang' oninput='updateLanguage();' title='Web page language ID'/>
    <a href='https://www.w3schools.com/tags/ref_language_codes.asp' target='_blank'>(W3 Schools reference)</a>
  </td>
</tr>

<tr>
  <th>
    Options
    <br/>
    <button onclick='doUpdateButton();' id='btnUpdate' disabled>Update</button>
  </th>
  <td>
    <input type='checkbox' id='cbNumbers' onclick='optionsChanged();' title='Include words that include numbers'>Numbers</input>
    <input type='checkbox' id='cbPunctuation' onclick='optionsChanged();' title='Include punctuation'>Punctuation</input>
    <input type='checkbox' id='cbJustWord' onclick='optionsChanged();' title='Include word when using punctuation' disabled>+Word</input>
    <input type='checkbox' id='cbNormalize' onclick='optionsChanged();' title='Unicode normalize the words'>Normalize</input>
    <input type='checkbox' id='cbSort' onclick='optionsChanged();' title='Sort the output words' checked>Sort</input>
    <br/>
    Ignore Characters: <input type='text' id='inputIgnore' size=64 oninput='optionsChanged();' title='Ignore words that include any of these characters'></input><br/>(use e.g. `\u06f0` for Unicode)    
  </td>
</tr>

<tr>
  <th>
    Known Words to Ignore
    <br/>
    <button onclick='clearIgnoreWords();' id='btnClearIgnore'>Clear</button>
    <button onclick='pasteIgnoreWords();' id='btnPasteIgnore'>Paste</button>
  </th>
  <td id='tdIgnoreWords'>
    (drag and drop .txt file)
  </td>
</tr>

<tr>
  <th>
    Input Text
    <br/>
    <button onclick='pasteInputText();' id='btnPaste'>Paste</button>
  </th>
  <td>
    <input type='checkbox' id='cbFilter' title='Enable RegExp filtering'>Filter</input>
    <button id='btnFilter'>RegExp...</button> <kbd><span id='filterState'>(off)</span></kbd>
    <dialog id='dlgFilter'>
      <button type="submit" aria-label="close" onclick="dlgFilter.close();">X</button>
      <h2>RegExp Filter</h2>
      <kbd>/<input type='text' style='font-family:monospace;' id='inputFilter'/>/gu</kbd>
      <br/>
      <font color='red'><span id='spanFilterError'></span></font>
      <br/>
      Test:
      <textarea style='width:100%;' id='textTestInput' rows=5 cols=40></textarea>
      <br/>
      Output:
      <textarea style='width:100%;' id='textTestOutput' rows=5 cols=40></textarea>      
    </dialog>
    <textarea style="width:100%;line-clamp:2000" id="inputText" rows='8' oninput="updateInputText();">(paste text here, or drag and drop .txt file)</textarea>
    <button id='btnAbort' hidden onclick='doAbortTheLoop();'>Abort</button>&nbsp;
    <span id='inputCount'>-</span>
  </td>
</tr>

<tr>
  <th>
    Unique Words
    <br/>
    <button onclick='copyUniqueWords();' id='btnCopyToClipboard'>Copy to Clipboard</button>
    <br/>
    <button onclick='downloadUniqueWords();' id='btnDownload'>Download</button>
  </th>
  <td>
    <textarea style="width:100%;line-clamp:2000" id="outputText" rows='20'></textarea><div id='uniqueCount'>-</div>
  </td>
</tr>
</table>
<script>
  patchDragDrop(inputText, handeInputDragDrop);
  patchDragDrop(tdIgnoreWords, handleIgnoreDragDrop);


//------------------------
// Filter Dialog Handling
//------------------------
function textTestInputChange() {
  const reTxt = inputFilter.value;
  textTestOutput.value = '';
  spanFilterError.innerText = '';
  filterState.innerText = '(off)';
  if (reTxt.length == 0) return;
  if (!reTxt.includes('(') || !reTxt.includes(')')) {
    spanFilterError.innerText = 'Include at least one group (...)';
    return;
  }
  try {
    const re = new RegExp(reTxt, 'gu');
    const txt = textTestInput.value;
    filterState.innerText = reTxt;
    let txtOut = '';

    let lines = txt.split(/\r?\n+/g);
    lines.forEach( (line) => {
      //const res = line.match(re);
      re.lastIndex = 0;
      let res = re.exec(line);
      if (res) {
        txtOut += res.slice(1).join(' ') + '\r\n';
      }
    });

    if (txtOut.length == 0)
      textTestOutput.value = '!NOTHING!';
    else {
      textTestOutput.value = txtOut;
    }
    spanFilterError.innerText = '';
  } catch(error) {
    spanFilterError.innerText = error.message;
  }
}

function dialogFilterClose(event) {
  processInputText();  
}

btnFilter.addEventListener('click', ()=>{dlgFilter.showModal();});
textTestInput.addEventListener('input', textTestInputChange);
inputFilter.addEventListener('input', textTestInputChange);
cbFilter.addEventListener('change', processInputText);
dlgFilter.addEventListener('close', dialogFilterClose);

</script>
<a href='https://github.com/MattMatic/unique-words'>github.com/MattMatic/unique-words</a>
<br/>2025-11-28
</body>
</html>
